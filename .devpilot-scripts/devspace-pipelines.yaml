version: v2beta1
name: common-scripts

localRegistry:
  enabled: false

vars:
  REGISTRY: "image.registry.local:5001"
  AZURE_REGISTRY:
    default: "kubecondemo.azurecr.io"
  IMAGE_TAG: "latest"
  # Use sanitized username as default namespace
  NAMESPACE:
    command: "echo $USER | tr '.' '-'"
  # Base directory for Kubernetes manifests
  K8S_DIR: ".."

# Generic images template - will be inherited by services
images:
  # Development image - uses Dockerfile.dev for hot reload and development tools
  dev:
    image: ${REGISTRY}/${SERVICE_NAME}
    dockerfile: ./Dockerfile.dev
    tags:
    - dev
    custom:
      command: |-
        docker build --tag ${runtime.images.dev.image}:${runtime.images.dev.tag} . -f Dockerfile.dev && docker push ${runtime.images.dev.image}:${runtime.images.dev.tag}

# Define reusable pipelines to reduce duplication
pipelines:
  # Build development image
  build-dev: 
    run: |-
      build_images dev --tag dev
  
  # Build production image
  build-prod: 
    run: |-
      build_images prod --tag ${IMAGE_TAG}
  # Enhanced logging functions
  enhanced-logging:
    run: |
      # Define colors for better visibility
      export RED='\033[0;31m'
      export GREEN='\033[0;32m'
      export YELLOW='\033[0;33m'
      export BLUE='\033[0;34m'
      export MAGENTA='\033[0;35m'
      export CYAN='\033[0;36m'
      export WHITE='\033[1;37m'
      export BOLD='\033[1m'
      export NC='\033[0m' # No Color
      
      # Log functions with timestamps
      function log_info() {
        echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')] ℹ️ INFO${NC}: $1"
      }
      
      function log_success() {
        echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] ✅ SUCCESS${NC}: $1"
      }
      
      function log_warning() {
        echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] ⚠️ WARNING${NC}: $1"
      }
      
      function log_error() {
        echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ❌ ERROR${NC}: $1"
      }
      
      function log_step() {
        echo -e "${MAGENTA}[$(date '+%Y-%m-%d %H:%M:%S')] 🔄 STEP${NC}: $1"
      }
      
      function log_phase() {
        echo
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${WHITE}${BOLD}[$(date '+%Y-%m-%d %H:%M:%S')] 🚀 PHASE: $1${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo
      }
      
      # Export functions to be used in subsequent pipeline steps
      export log_info log_success log_warning log_error log_step log_phase
      
      # Create file with functions to be sourced by other scripts
      mkdir -p ~/.devspace/vars
      cat << 'EOF' > ~/.devspace/vars/logging.sh
      # Define colors for better visibility
      export RED='\033[0;31m'
      export GREEN='\033[0;32m'
      export YELLOW='\033[0;33m'
      export BLUE='\033[0;34m'
      export MAGENTA='\033[0;35m'
      export CYAN='\033[0;36m'
      export WHITE='\033[1;37m'
      export BOLD='\033[1m'
      export NC='\033[0m' # No Color
      
      # Log functions with timestamps
      function log_info() {
        echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')] ℹ️ INFO${NC}: $1"
      }
      
      function log_success() {
        echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] ✅ SUCCESS${NC}: $1"
      }
      
      function log_warning() {
        echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] ⚠️ WARNING${NC}: $1"
      }
      
      function log_error() {
        echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ❌ ERROR${NC}: $1"
      }
      
      function log_step() {
        echo -e "${MAGENTA}[$(date '+%Y-%m-%d %H:%M:%S')] 🔄 STEP${NC}: $1"
      }
      
      function log_phase() {
        echo
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${WHITE}${BOLD}[$(date '+%Y-%m-%d %H:%M:%S')] 🚀 PHASE: $1${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo
      }
      
      function kube_check_pod_status() {
        local namespace=$1
        local selector=$2
        local pods=$(kubectl get pods -n $namespace -l $selector -o name)
        
        if [ -z "$pods" ]; then
          log_warning "No pods found with selector $selector in namespace $namespace"
          return 1
        fi
        
        log_info "Found pods: $pods"
        
        for pod in $pods; do
          log_step "Checking status of $pod"
          kubectl get $pod -n $namespace -o wide
          log_step "Recent logs from $pod:"
          kubectl logs $pod -n $namespace --tail=20
        done
      }
      EOF

  # Pipeline for ACR authentication
  azure-acr-login:
    run: |
      source ~/.devspace/vars/logging.sh
      
      log_phase "AUTHENTICATING WITH AZURE"
      
      log_step "Logging into Azure..."
      if az login --output none; then
        log_success "Successfully logged into Azure"
      else
        log_error "Failed to log into Azure"
        exit 1
      fi
      
      log_step "Logging into Azure Container Registry using Azure identity..."
      if az acr login --name kubecondemo2-cfcrhfdceae9g7hf; then
        log_success "Successfully logged into ACR"
      else
        log_error "Failed to log into ACR"
        exit 1
      fi

  # Common pipeline to prepare manifests with namespace replacement
  prepare-manifests:
    run: |
      source ~/.devspace/vars/logging.sh
      
      log_phase "PREPARING KUBERNETES MANIFESTS"
      
      # Create a temporary directory for the customized yaml
      TEMP_DIR=$(mktemp -d)
      log_info "Creating temporary files in $TEMP_DIR"
      echo "export TEMP_DIR=$TEMP_DIR" > ~/.devspace/vars/temp_dir.env
      
      # Get the base directory
      source ~/.devspace/vars/env_type.env
      source ~/.devspace/vars/k8s_path.env
      MANIFEST_PATH="${K8S_PATH}"
      SERVICE_DIR=$(basename "${MANIFEST_PATH}")
      BASE_DIR=$(dirname "${MANIFEST_PATH}")
      BASE_DIR=$(dirname "$BASE_DIR")
      BASE_DIR=$(dirname "$BASE_DIR")
      
      log_step "Service: ${SERVICE_DIR} | Environment: ${ENV_TYPE}"
      
      # Copy the necessary files to the temp directory
      log_step "Copying base and overlay files"
      mkdir -p $TEMP_DIR/base $TEMP_DIR/overlays/$ENV_TYPE
      cp -r ${BASE_DIR}/base/* $TEMP_DIR/base/
      cp -r ${BASE_DIR}/overlays/$ENV_TYPE/* $TEMP_DIR/overlays/$ENV_TYPE/
      
      # Save paths for later steps
      echo "export SERVICE_DIR=$SERVICE_DIR" >> ~/.devspace/vars/temp_dir.env
      echo "export BASE_DIR=$BASE_DIR" >> ~/.devspace/vars/temp_dir.env
      
      # Replace in all yaml files
      log_step "Replacing namespace placeholders with: ${NAMESPACE}"
      find $TEMP_DIR -type f -name "*.yaml" -exec sed -i "s/NAMESPACE_PLACEHOLDER/${NAMESPACE}/g" {} \;
      
      # Create or verify namespace
      log_step "Setting up namespace: ${NAMESPACE}"
      if kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -; then
        log_success "Namespace ${NAMESPACE} configured successfully"
      else
        log_error "Failed to configure namespace ${NAMESPACE}"
        exit 1
      fi
      
      log_success "Prepared Kubernetes manifests in $TEMP_DIR with namespace: ${NAMESPACE}"

  # Apply the prepared manifests
  apply-manifests:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      source ~/.devspace/vars/env_type.env
      
      log_phase "DEPLOYING RESOURCES TO KUBERNETES"
      
      # Print all files being applied for clarity
      log_step "Listing all Kubernetes manifests to be applied:"
      find $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR -type f -name "*.yaml" | sort
      
      # Print which environment and path we're applying
      log_step "🔍 APPLYING: $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR (Environment: ${ENV_TYPE})"
      
      # Apply the manifests with clear indication of success/failure
      if kubectl apply -k $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR; then
        log_success "Resources applied successfully"
      else
        log_error "Failed to apply resources"
        exit 1
      fi
      
      # Display what was deployed
      log_info "Deployed resources:"
      kubectl get all -n ${NAMESPACE} -l app=${SERVICE_DIR%-deployment}
      
      # Handle Istio Gateway for Azure environment
      if [[ "$ENV_TYPE" == "azure" ]]; then
        log_step "Checking Istio Gateway configuration"
        
        # Check if the Istio Gateway exists in the aks-istio-ingress namespace
        GATEWAY_EXISTS=$(kubectl get gateway -n aks-istio-ingress store-ui-gateway -o name --ignore-not-found)
        
        if [ -z "$GATEWAY_EXISTS" ]; then
          log_info "Creating Istio Gateway in aks-istio-ingress namespace"
          # Apply the Gateway configuration separately since it's in a different namespace
          GATEWAY_FILE="${BASE_DIR}/overlays/azure/store-ui/store-ui-gateway.yaml"
          log_step "🔍 APPLYING GATEWAY: $GATEWAY_FILE"
          if [ -f "$GATEWAY_FILE" ]; then
            if kubectl apply -f "$GATEWAY_FILE"; then
              log_success "Istio Gateway created successfully"
            else
              log_warning "Failed to create Istio Gateway"
            fi
          else
            log_warning "Gateway file not found: $GATEWAY_FILE"
          fi
        else
          log_info "Istio Gateway already exists in aks-istio-ingress namespace"
        fi
      fi
  
  # Delete the prepared manifests
  delete-manifests:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      source ~/.devspace/vars/env_type.env
      
      log_phase "REMOVING RESOURCES FROM KUBERNETES"
      
      log_step "Deleting Kubernetes resources for ${SERVICE_DIR} in ${ENV_TYPE} environment"
      if kubectl delete -k $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR --ignore-not-found; then
        log_success "Resources deleted successfully"
      else
        log_warning "Issues encountered while deleting resources"
      fi
  
  # Clean up the temporary directory
  cleanup:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      
      log_phase "CLEANUP"
      
      log_step "Removing temporary directory: $TEMP_DIR"
      rm -rf $TEMP_DIR
      log_success "Cleaned up temporary directory"
      
  # Verify deployment and show status
  verify-deployment:
    run: |
      source ~/.devspace/vars/logging.sh
      
      log_phase "VERIFYING DEPLOYMENT STATUS"
      
      log_step "Checking pods in namespace ${NAMESPACE}"
      kubectl get pods -n ${NAMESPACE} -o wide
      
      log_step "Checking services in namespace ${NAMESPACE}"
      kubectl get svc -n ${NAMESPACE}
      
      if [[ "${SERVICE_NAME}" == "store-ui" ]]; then
        log_step "Checking store-ui specific resources"
        kube_check_pod_status ${NAMESPACE} "app=store-ui-deployment"
      elif [[ "${SERVICE_NAME}" == "cart" ]]; then
        log_step "Checking cart service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=cart-deployment"
      elif [[ "${SERVICE_NAME}" == "products" ]]; then
        log_step "Checking products service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=products-deployment"
      elif [[ "${SERVICE_NAME}" == "search" ]]; then
        log_step "Checking search service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=search-deployment"
      elif [[ "${SERVICE_NAME}" == "users" ]]; then
        log_step "Checking users service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=users-deployment"
      fi
      
      if [[ "$ENV_TYPE" == "azure" ]]; then
        log_step "Checking Istio resources"
        kubectl get virtualservices -n ${NAMESPACE}
        kubectl get gateways -n aks-istio-ingress
      fi
      
      log_success "Deployment verification completed"

# Standardized commands for consistency across all microservices
commands:
  # Development commands
  dev:
    command: devspace use namespace ${NAMESPACE} && devspace dev --skip-build --skip-deploy
    description: "Start development mode with hot reload"
   # Development commands
  develop:
    command: devspace use namespace ${NAMESPACE} && devspace run dev
    description: "Start the cart service in development mode with hot reload and debugging support."
  debug:
    command: devspace use namespace ${NAMESPACE} && devspace run-pipeline debug-server
    description: "Attach to the debug server for remote debugging. Does not modify the application, but allows you to debug it remotely."
  stop:
    command: devspace use namespace ${NAMESPACE} && devspace purge
    description: "Stop the cart service and clean up resources."
  # Core deployment commands  
  deploy:
    command: |
      # Check if Azure profile is specified
      if [[ "$*" == *"--profile azure"* ]]; then
        # Initialize enhanced logging
        devspace run-pipeline enhanced-logging
        devspace run-pipeline build-dev
        # Source the logging functions
        source ~/.devspace/vars/logging.sh
        
        log_phase "STARTING AZURE DEPLOYMENT FOR ${SERVICE_NAME}"
        
        mkdir -p ~/.devspace/vars
        # Set environment variables for pipelines
        log_step "Setting environment variables for Azure deployment"
        echo "export ENV_TYPE=azure" > ~/.devspace/vars/env_type.env
        echo "export K8S_PATH=${K8S_MANIFEST_PATH_AZURE}" > ~/.devspace/vars/k8s_path.env
        
        # Run pipelines with better feedback
        log_step "Preparing Kubernetes manifests"
        devspace run-pipeline prepare-manifests
        
        log_step "Applying Kubernetes manifests"
        devspace run-pipeline apply-manifests
        
        log_step "Verifying deployment"
        devspace run-pipeline verify-deployment
        
        log_step "Cleaning up temporary files"
        devspace run-pipeline cleanup
        
        log_phase "DEPLOYMENT SUMMARY"
        log_info "Service: ${SERVICE_NAME}"
        log_info "Namespace: ${NAMESPACE}"
        log_info "Environment: Azure"
        
        if [[ "${SERVICE_NAME}" == "store-ui" ]]; then
          log_info "Access URL: http://your-istio-gateway-ip"
          log_step "To get the gateway IP, run: kubectl get svc -n aks-istio-ingress"
        fi
        
        log_success "✨ Azure deployment completed successfully! ✨"
      else
        # Local deployment
        devspace run-pipeline build-dev
        mkdir -p ~/.devspace/vars
        # Set environment variables for pipelines
        echo "export ENV_TYPE=local" > ~/.devspace/vars/env_type.env
        echo "export K8S_PATH=${K8S_MANIFEST_PATH_LOCAL}" > ~/.devspace/vars/k8s_path.env
        
        # Run pipelines
        devspace run-pipeline prepare-manifests
        devspace run-pipeline apply-manifests
        devspace run-pipeline cleanup
      fi
    description: "Deploy to environment (use --profile azure for Azure deployment)"
  
  build:
    command: |
      # Check if Azure profile is specified
      if [[ "$*" == *"--profile azure"* ]]; then
        # Initialize enhanced logging
        devspace run-pipeline enhanced-logging
        
        # Source the logging functions
        source ~/.devspace/vars/logging.sh
        
        log_phase "BUILDING IMAGE FOR AZURE CONTAINER REGISTRY"
        
        # First login to Azure Container Registry
        # log_step "Authenticating with Azure Container Registry"
        # devspace run-pipeline azure-acr-login
        
        # Then build and push with Azure profile
        log_step "Building and pushing image to ACR: ${AZURE_REGISTRY}/${SERVICE_NAME}:${IMAGE_TAG}"
        if devspace run-pipeline build-dev --profile azure; then
          log_success "Image built and pushed to ACR successfully"
          log_info "Image: ${AZURE_REGISTRY}/${SERVICE_NAME}:${IMAGE_TAG}"
        else
          log_error "Failed to build or push image to ACR"
          exit 1
        fi
        
        log_success "✨ Azure image build completed successfully! ✨"
      else
        # Local build
        devspace run-pipeline build-dev
      fi
    description: "Build image (use --profile azure for Azure Container Registry)"
  
  rollback:
    command: |
      mkdir -p ~/.devspace/vars
      # Set environment variables for pipelines
      echo "export ENV_TYPE=local" > ~/.devspace/vars/env_type.env
      echo "export K8S_PATH=${K8S_MANIFEST_PATH_LOCAL}" > ~/.devspace/vars/k8s_path.env
      
      # Run pipelines
      devspace run-pipeline prepare-manifests
      devspace run-pipeline delete-manifests
      devspace run-pipeline cleanup
    description: "Remove deployment from cluster"
  
  purge:
    command: |
      # Check if Azure profile is specified
      if [[ "$*" == *"--profile azure"* ]]; then
        mkdir -p ~/.devspace/vars
        # Set environment variables for pipelines
        echo "export ENV_TYPE=azure" > ~/.devspace/vars/env_type.env
        echo "export K8S_PATH=${K8S_MANIFEST_PATH_AZURE}" > ~/.devspace/vars/k8s_path.env
        # Run pipelines
        devspace run-pipeline prepare-manifests
        devspace run-pipeline delete-manifests
        devspace run-pipeline cleanup
      else
        mkdir -p ~/.devspace/vars
        # Set environment variables for pipelines
        echo "export ENV_TYPE=local" > ~/.devspace/vars/env_type.env
        echo "export K8S_PATH=${K8S_MANIFEST_PATH_LOCAL}" > ~/.devspace/vars/k8s_path.env
      fi
    description: "Remove deployment from cluster (use --profile azure for Azure)"

# Azure ACR profile for Kubernetes
profiles:
  - name: azure
    description: "Azure ACR for Kubernetes deployment"
    patches:
      - op: replace
        path: vars.REGISTRY
        value: ${AZURE_REGISTRY}
    activation:
      - vars:
          DEVSPACE_PROFILE: "azure"