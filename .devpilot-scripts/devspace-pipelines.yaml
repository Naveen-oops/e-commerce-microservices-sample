version: v2beta1
name: common-scripts

localRegistry:
  enabled: false

vars:
  REGISTRY: "kubecon.azurecr.io"
  IMAGE_TAG: "latest"
  # Use sanitized username as default namespace
  NAMESPACE:
    command: "echo $USER | tr '.' '-'"
  # Base directory for Kubernetes manifests
  K8S_DIR: ".."

# Define reusable pipelines to reduce duplication
pipelines:
  # Enhanced logging functions
  enhanced-logging:
    run: |
      # Define colors for better visibility
      export RED='\033[0;31m'
      export GREEN='\033[0;32m'
      export YELLOW='\033[0;33m'
      export BLUE='\033[0;34m'
      export MAGENTA='\033[0;35m'
      export CYAN='\033[0;36m'
      export WHITE='\033[1;37m'
      export BOLD='\033[1m'
      export NC='\033[0m' # No Color
      
      # Log functions with timestamps
      function log_info() {
        echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')] ℹ️ INFO${NC}: $1"
      }
      
      function log_success() {
        echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] ✅ SUCCESS${NC}: $1"
      }
      
      function log_warning() {
        echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] ⚠️ WARNING${NC}: $1"
      }
      
      function log_error() {
        echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ❌ ERROR${NC}: $1"
      }
      
      function log_step() {
        echo -e "${MAGENTA}[$(date '+%Y-%m-%d %H:%M:%S')] 🔄 STEP${NC}: $1"
      }
      
      function log_phase() {
        echo
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${WHITE}${BOLD}[$(date '+%Y-%m-%d %H:%M:%S')] 🚀 PHASE: $1${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo
      }
      
      # Export functions to be used in subsequent pipeline steps
      export log_info log_success log_warning log_error log_step log_phase
      
      # Create file with functions to be sourced by other scripts
      mkdir -p ~/.devspace/vars
      cat << 'EOF' > ~/.devspace/vars/logging.sh
      # Define colors for better visibility
      export RED='\033[0;31m'
      export GREEN='\033[0;32m'
      export YELLOW='\033[0;33m'
      export BLUE='\033[0;34m'
      export MAGENTA='\033[0;35m'
      export CYAN='\033[0;36m'
      export WHITE='\033[1;37m'
      export BOLD='\033[1m'
      export NC='\033[0m' # No Color
      
      # Log functions with timestamps
      function log_info() {
        echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')] ℹ️ INFO${NC}: $1"
      }
      
      function log_success() {
        echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] ✅ SUCCESS${NC}: $1"
      }
      
      function log_warning() {
        echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] ⚠️ WARNING${NC}: $1"
      }
      
      function log_error() {
        echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ❌ ERROR${NC}: $1"
      }
      
      function log_step() {
        echo -e "${MAGENTA}[$(date '+%Y-%m-%d %H:%M:%S')] 🔄 STEP${NC}: $1"
      }
      
      function log_phase() {
        echo
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${WHITE}${BOLD}[$(date '+%Y-%m-%d %H:%M:%S')] 🚀 PHASE: $1${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo
      }
      
      function kube_check_pod_status() {
        local namespace=$1
        local selector=$2
        local pods=$(kubectl get pods -n $namespace -l $selector -o name)
        
        if [ -z "$pods" ]; then
          log_warning "No pods found with selector $selector in namespace $namespace"
          return 1
        fi
        
        log_info "Found pods: $pods"
        
        for pod in $pods; do
          log_step "Checking status of $pod"
          kubectl get $pod -n $namespace -o wide
          log_step "Recent logs from $pod:"
          kubectl logs $pod -n $namespace --tail=20
        done
      }
      EOF

  # Pipeline for ACR authentication
  azure-acr-login:
    run: |
      source ~/.devspace/vars/logging.sh
      
      log_phase "AUTHENTICATING WITH AZURE"
      
      log_step "Logging into Azure Container Registry using Azure identity..."
      if az acr login --name kubecondemo; then
        log_success "Successfully logged into ACR"
      else
        log_error "Failed to log into ACR"
        exit 1
      fi

  # Common pipeline to prepare manifests with namespace replacement
  prepare-manifests:
    run: |
      source ~/.devspace/vars/logging.sh
      
      log_phase "PREPARING KUBERNETES MANIFESTS"
      
      # Create a temporary directory for the customized yaml
      TEMP_DIR=$(mktemp -d)
      log_info "Creating temporary files in $TEMP_DIR"
      echo "export TEMP_DIR=$TEMP_DIR" > ~/.devspace/vars/temp_dir.env
      
      # Get the base directory
      source ~/.devspace/vars/env_type.env
      source ~/.devspace/vars/k8s_path.env
      MANIFEST_PATH="${K8S_PATH}"
      SERVICE_DIR=$(basename "${MANIFEST_PATH}")
      BASE_DIR=$(dirname "${MANIFEST_PATH}")
      BASE_DIR=$(dirname "$BASE_DIR")
      BASE_DIR=$(dirname "$BASE_DIR")
      
      log_step "Service: ${SERVICE_DIR} | Environment: ${ENV_TYPE}"
      
      # Copy the necessary files to the temp directory
      log_step "Copying base and overlay files"
      mkdir -p $TEMP_DIR/base $TEMP_DIR/overlays/$ENV_TYPE
      cp -r ${BASE_DIR}/base/* $TEMP_DIR/base/
      cp -r ${BASE_DIR}/overlays/$ENV_TYPE/* $TEMP_DIR/overlays/$ENV_TYPE/
      
      # Save paths for later steps
      echo "export SERVICE_DIR=$SERVICE_DIR" >> ~/.devspace/vars/temp_dir.env
      echo "export BASE_DIR=$BASE_DIR" >> ~/.devspace/vars/temp_dir.env
      
      # Replace in all yaml files
      log_step "Replacing namespace placeholders with: ${NAMESPACE}"
      find $TEMP_DIR -type f -name "*.yaml" -exec sed -i "s/e-commerce/${NAMESPACE}/g" {} \;
      
      # Create or verify namespace
      log_step "Setting up namespace: ${NAMESPACE}"
      if kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -; then
        log_success "Namespace ${NAMESPACE} configured successfully"
      else
        log_error "Failed to configure namespace ${NAMESPACE}"
        exit 1
      fi
      
      log_success "Prepared Kubernetes manifests in $TEMP_DIR with namespace: ${NAMESPACE}"

  # Replace image tags for development deployment
  replace-image-tags-dev:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      
      log_step "Replacing image tags from 'latest' to 'dev'"
      find $TEMP_DIR -type f -name "*.yaml" -exec sed -i "s/:latest/:dev/g" {} \;
      
      log_success "Prepared Kubernetes manifests in $TEMP_DIR with namespace: ${NAMESPACE}"

  # Apply the prepared manifests
  apply-manifests:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      source ~/.devspace/vars/env_type.env
      
      log_phase "DEPLOYING RESOURCES TO KUBERNETES"
      
      # Print all files being applied for clarity
      log_step "Listing all Kubernetes manifests to be applied:"
      find $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR -type f -name "*.yaml" | sort
      
      # Print which environment and path we're applying
      log_step "🔍 APPLYING: $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR (Environment: ${ENV_TYPE})"
      
      # Apply the manifests with clear indication of success/failure
      if kubectl apply -k $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR; then
        log_success "Resources applied successfully"
      else
        log_error "Failed to apply resources"
        exit 1
      fi
      
      # Display what was deployed
      log_info "Deployed resources:"
      kubectl get all -n ${NAMESPACE} -l app=${SERVICE_DIR%-deployment}

  # Delete resources using kubectl delete -k
  delete-k8s-manifests:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      source ~/.devspace/vars/env_type.env
      
      log_phase "DELETING RESOURCES FROM KUBERNETES USING KUSTOMIZE"
      
      # Print all files being deleted for clarity
      log_step "Listing all Kubernetes manifests to be deleted:"
      find $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR -type f -name "*.yaml" | sort
      
      # Print which environment and path we're deleting from
      log_step "🔍 DELETING: $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR (Environment: ${ENV_TYPE})"
      
      # Delete the manifests with clear indication of success/failure
      if kubectl delete -k $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR --ignore-not-found; then
        log_success "Resources deleted successfully"
      else
        log_warning "Issues encountered while deleting resources (some resources may not have existed)"
      fi
      
      # Show remaining resources after deletion
      log_info "Remaining resources in namespace ${NAMESPACE}:"
      kubectl get all -n ${NAMESPACE} -l app=${SERVICE_DIR%-deployment} || log_info "No resources found (expected after successful deletion)"
  
  # Delete the prepared manifests
  delete-manifests:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      source ~/.devspace/vars/env_type.env
      
      log_phase "REMOVING RESOURCES FROM KUBERNETES"
      
      log_step "Deleting Kubernetes resources for ${SERVICE_DIR} in ${ENV_TYPE} environment"
      if kubectl delete -k $TEMP_DIR/overlays/$ENV_TYPE/$SERVICE_DIR --ignore-not-found; then
        log_success "Resources deleted successfully"
      else
        log_warning "Issues encountered while deleting resources"
      fi
  
  # Clean up the temporary directory
  cleanup:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/temp_dir.env
      
      log_phase "CLEANUP"
      
      log_step "Removing temporary directory: $TEMP_DIR"
      rm -rf $TEMP_DIR
      log_success "Cleaned up temporary directory"
      
  # Verify deployment and show status
  verify-deployment:
    run: |
      source ~/.devspace/vars/logging.sh
      source ~/.devspace/vars/env_type.env
      
      log_phase "VERIFYING DEPLOYMENT STATUS"
      
      log_step "Checking pods in namespace ${NAMESPACE}"
      kubectl get pods -n ${NAMESPACE} -o wide
      
      log_step "Checking services in namespace ${NAMESPACE}"
      kubectl get svc -n ${NAMESPACE}
      
      if [[ "${SERVICE_NAME}" == "store-ui" ]]; then
        log_step "Checking store-ui specific resources"
        kube_check_pod_status ${NAMESPACE} "app=store-ui-deployment"
      elif [[ "${SERVICE_NAME}" == "cart" ]]; then
        log_step "Checking cart service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=cart-deployment"
      elif [[ "${SERVICE_NAME}" == "products" ]]; then
        log_step "Checking products service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=products-deployment"
      elif [[ "${SERVICE_NAME}" == "search" ]]; then
        log_step "Checking search service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=search-deployment"
      elif [[ "${SERVICE_NAME}" == "users" ]]; then
        log_step "Checking users service specific resources"
        kube_check_pod_status ${NAMESPACE} "app=users-deployment"
      fi
      
      if [[ "$ENV_TYPE" == "azure" ]]; then
        log_step "Checking Istio resources"
        kubectl get virtualservices -n ${NAMESPACE}
        kubectl get gateways -n aks-istio-ingress
      fi
      
      log_success "Deployment verification completed"

# Standardized commands for consistency across all microservices
commands:
  # Development commands
  start:
    command: devspace use namespace ${NAMESPACE} && devspace dev --skip-build --skip-deploy
    description: "Start development mode with hot reload"
  debug:
    command: devspace use namespace ${NAMESPACE} && devspace run-pipeline debug-server
    description: "Attach to the debug server for remote debugging. Does not modify the application, but allows you to debug it remotely."
  stop:
    command: devspace use namespace ${NAMESPACE} && devspace reset pods
    description: "Stop the dev or debug service and clean up pods."
  # Core deployment commands  
  deploy-aks:
    command: |
      # Initialize enhanced logging
      devspace run-pipeline enhanced-logging
      ../.devpilot-scripts/build-and-push-images.sh -s $SERVICE_NAME -p azure --dev-only
      # Source the logging functions
      source ~/.devspace/vars/logging.sh
      
      log_phase "STARTING AZURE DEPLOYMENT FOR ${SERVICE_NAME}"
      
      mkdir -p ~/.devspace/vars
      # Set environment variables for pipelines
      log_step "Setting environment variables for Azure deployment"
      echo "export ENV_TYPE=azure" > ~/.devspace/vars/env_type.env
      echo "export K8S_PATH=${K8S_MANIFEST_PATH_AZURE}" > ~/.devspace/vars/k8s_path.env
      
      # Run pipelines with better feedback
      log_step "Preparing Kubernetes manifests"
      devspace run-pipeline prepare-manifests
      
      log_step "Replacing image tags to dev for development deployment"
      devspace run-pipeline replace-image-tags-dev
      
      log_step "Applying Kubernetes manifests"
      devspace run-pipeline apply-manifests
      
      log_step "Verifying deployment"
      devspace run-pipeline verify-deployment
      
      log_step "Cleaning up temporary files"
      devspace run-pipeline cleanup
      
      log_phase "DEPLOYMENT SUMMARY"
      log_info "Service: ${SERVICE_NAME}"
      log_info "Namespace: ${NAMESPACE}"
      log_info "Environment: Azure"
      
      if [[ "${SERVICE_NAME}" == "store-ui" ]]; then
        log_info "Access URL: http://your-istio-gateway-ip"
        log_step "To get the gateway IP, run: kubectl get svc -n aks-istio-ingress"
      fi
      
      log_success "✨ Azure deployment completed successfully! ✨"
    description: "Deploy to AKS environment)"
  
  build-push-acr:
    command: |
      # Initialize enhanced logging
      devspace run-pipeline enhanced-logging
      
      # Source the logging functions
      source ~/.devspace/vars/logging.sh
      
      log_phase "BUILDING IMAGE FOR AZURE CONTAINER REGISTRY"
      
      # # First login to Azure Container Registry
      # log_step "Authenticating with Azure Container Registry"
      # devspace run-pipeline azure-acr-login
      
      # Then build and push with Azure profile
      log_step "Building and pushing image to ACR: ${AZURE_REGISTRY}/${SERVICE_NAME}:${IMAGE_TAG}"
      if ../.devpilot-scripts/build-and-push-images.sh -s $SERVICE_NAME -p azure --dev-only; then
        log_success "Image built and pushed to ACR successfully"
        log_info "Image: ${AZURE_REGISTRY}/${SERVICE_NAME}:${IMAGE_TAG}"
      else
        log_error "Failed to build or push image to ACR"
        exit 1
      fi
      
      log_success "✨ Azure image build completed successfully! ✨"
    description: "Build and push image to Azure Container Registry"

  purge-aks:
    command: |
      # Initialize enhanced logging
      devspace run-pipeline enhanced-logging
      
      # Source the logging functions
      source ~/.devspace/vars/logging.sh
      
      log_phase "DELETING DEPLOYMENT FROM AZURE ENVIRONMENT"
      
      mkdir -p ~/.devspace/vars
      # Set environment variables for pipelines
      echo "export ENV_TYPE=azure" > ~/.devspace/vars/env_type.env
      echo "export K8S_PATH=${K8S_MANIFEST_PATH_AZURE}" > ~/.devspace/vars/k8s_path.env
      
      # Run pipelines with better feedback
      log_step "Preparing Kubernetes manifests for deletion"
      devspace run-pipeline prepare-manifests
      
      log_step "Deleting Kubernetes resources using kubectl delete -k"
      devspace run-pipeline delete-k8s-manifests
      
      log_step "Cleaning up temporary files"
      devspace run-pipeline cleanup
      
      log_phase "DELETION SUMMARY"
      log_info "Service: ${SERVICE_NAME}"
      log_info "Namespace: ${NAMESPACE}"
      log_info "Environment: Azure"
      
      log_success "✨ Azure deployment deletion completed successfully! ✨"
    description: "Delete deployment in AKS"

  rollback-aks:
    command: |
      # Initialize enhanced logging
      devspace run-pipeline enhanced-logging
      
      # Source the logging functions
      source ~/.devspace/vars/logging.sh
      
      log_phase "DELETING DEPLOYMENT FROM AZURE ENVIRONMENT"
      
      mkdir -p ~/.devspace/vars
      # Set environment variables for pipelines
      echo "export ENV_TYPE=azure" > ~/.devspace/vars/env_type.env
      echo "export K8S_PATH=${K8S_MANIFEST_PATH_AZURE}" > ~/.devspace/vars/k8s_path.env
      
      # Run pipelines with better feedback
      log_step "Preparing Kubernetes manifests for deletion"
      devspace run-pipeline prepare-manifests
      
      log_step "Deleting Kubernetes resources using kubectl delete -k"
      devspace run-pipeline delete-k8s-manifests
      
      log_step "Cleaning up temporary files"
      devspace run-pipeline cleanup
      
      log_phase "DELETION SUMMARY"
      log_info "Service: ${SERVICE_NAME}"
      log_info "Namespace: ${NAMESPACE}"
      log_info "Environment: Azure"
      
      log_success "✨ Azure deployment deletion completed successfully! ✨"
    description: "Delete deployment in AKS"